BECIRSPAHIC LUCAS

==============================================
EXERCICE 1
==============================================

1) On a C1 = r(a,b)
     C2 = not(p(X,Y)) V r(f(X), Y)
     C3 = not(r(X,Y)) V p(f(X), Y)
     not(G) = not(r(f(f(a)),b))

G = r(f(f(a)),b)

i1 : (sigma(not(G)), sigma(c2))
unification ; on pose sigma = [Y = b; X = f(a) ]
dans ce cas C2 = not(p(f(a),b)) V (r(f(f(a)),b))
i1 retourne C4 = not(p(f(a), b))

i2 : (sigma(C4), sigma(c3))
unification : on pose sigma = [X = a; Y = b]
i2 retourne C5 = not(r(a,b))

i3 : C5, C1
retourne rien
Donc la formule r(f(f(a),b)) est vraie.

Trace de prolog :
Dans les lignes, il dit que pour montrer r(f(f(a)),b), il faut montrer p(f(a),b) par C2 et pour ce faire r(a,b).
Conclusion : A chaue fois prolog part de la formule de départ et cherche ce qu'il faut montrer pour l'avoir , puis apres il remonte en montrant que les conditions sont respectées.

F2 = p(f(a),b)

On rajoute not(F2) a nos clauses.
On a F1 = Res(not(F2), C3) avec sigma = [X = a; Y = b]
     F2 = Res(F1, C1)
     F3 = clash
     
==========================================
EXERICE 2
==========================================

1) On obtient les clauses :
C1 = r(a,b)
C2 = q(X,X)
C3 = not(r(X,Y)) V (not(Q(X,Z))) V q(X,Z)
not(G1) = not(q(X,b))

F1 = res(not(G1), c2) avec sigma = [X = b]
F2 = clash

2) Analyses des traces :
-----------------------------------
[trace]  ?- q(X,b).
   Call: (6) q(_G3758, b) ? creep
   Exit: (6) q(b, b) ? creep
X = b .
----------------------------------
_G3758 correspond à un nom de variable pour prolog
le call correspond a la formule G.
le exit il dit que q(b,b) rend la formule vraie.
donc il nous retourne que X = b.


2ème solutions.
Redo: (6) q(_G2831, b) ? creep
Call: (7) r(_G2831, _G2905) ? creep
Exit: (7) r(a, b) ? creep
Call: (7) q(b, b) ? creep
Exit: (7) q(b, b) ? creep
Exit: (6) q(a, b) ? creep
cette fois si il utilise la formule C3
on a F1 = R(not(G), C3) sigma = (Z = b, X = _G2831)
     F2 = R(F1, C4) sigma = (_G2831 = a, Y = b)
     F3 = R(C2,C3) sigma (X = b)
 


==============================================
EXERCICE 3
==============================================

1) LANGAGE HUMAIN
   C1 = (serieux(X) -> R(E)) = not(serieux(X)) V Revise(E)
   C2 = (C(X) -> Devoir(X))
   C3 = (serieux(X) -> reussit(E))
   C4 = (Devoir(X) -> serieux(X))
   C5 = C(Pascal)
   C6 = C(Zoe)

prolog:
---------------------------
reussit(X) :- serieux(X).
devoir(X) :- cons(X).
serieux(X) :- devoir(X).
cons(pascal).
cons(zoe).

2) Requête : reussit(X)
prolog nous renvoi les valeurs que peut prendre la variable X c'est à dire les étudiants qui réussissent.

3) Le resultat de la requête est : Pascal, Zoe

4)

===========================
EXERCICE 4
===========================
