BECIRSPAHIC LUCAS

==============================================
EXERCICE 1
==============================================

1) On a C1 = r(a,b)
     C2 = not(p(X,Y)) V r(f(X), Y)
     C3 = not(r(X,Y)) V p(f(X), Y)
     not(G) = not(r(f(f(a)),b))

G = r(f(f(a)),b)

i1 : (sigma(not(G)), sigma(c2))
unification ; on pose sigma = [Y = b; X = f(a) ]
dans ce cas C2 = not(p(f(a),b)) V (r(f(f(a)),b))
i1 retourne C4 = not(p(f(a), b))

i2 : (sigma(C4), sigma(c3))
unification : on pose sigma = [X = a; Y = b]
i2 retourne C5 = not(r(a,b))

i3 : C5, C1
retourne rien
Donc la formule r(f(f(a),b)) est vraie.

Trace de prolog :
Dans les lignes, il dit que pour montrer r(f(f(a)),b), il faut montrer p(f(a),b) par C2 et pour ce faire r(a,b).
Conclusion : A chaue fois prolog part de la formule de départ et cherche ce qu'il faut montrer pour l'avoir , puis apres il remonte en montrant que les conditions sont respectées.

F2 = p(f(a),b)

On rajoute not(F2) a nos clauses.
On a F1 = Res(not(F2), C3) avec sigma = [X = a; Y = b]
     F2 = Res(F1, C1)
     F3 = clash
     
==========================================
EXERICE 2
==========================================

1) On obtient les clauses :
C1 = r(a,b)
C2 = q(X,X)
C3 = not(r(X,Y)) V (not(Q(X,Z))) V q(X,Z)
not(G1) = not(q(X,b))

F1 = res(not(G1), c2) avec sigma = [X = b]
F2 = clash

2) Analyses des traces :
-----------------------------------
[trace]  ?- q(X,b).
   Call: (6) q(_G3758, b) ? creep
   Exit: (6) q(b, b) ? creep
X = b .
----------------------------------
_G3758 correspond à un nom de variable pour prolog
le call correspond a la formule G.
le exit il dit que q(b,b) rend la formule vraie.
donc il nous retourne que X = b.


2ème solutions.
Redo: (6) q(_G2831, b) ? creep
Call: (7) r(_G2831, _G2905) ? creep
Exit: (7) r(a, b) ? creep
Call: (7) q(b, b) ? creep
Exit: (7) q(b, b) ? creep
Exit: (6) q(a, b) ? creep
cette fois si il utilise la formule C3
on a F1 = R(not(G), C3) sigma = (Z = b, X = _G2831)
     F2 = R(F1, C4) sigma = (_G2831 = a, Y = b)
     F3 = R(C2,C3) sigma (X = b)
 


==============================================
EXERCICE 3
==============================================

1) LANGAGE HUMAIN
   C1 = (serieux(X) -> R(E)) = not(serieux(X)) V Revise(E)
   C2 = (C(X) -> Devoir(X))
   C3 = (serieux(X) -> reussit(E))
   C4 = (Devoir(X) -> serieux(X))
   C5 = C(Pascal)
   C6 = C(Zoe)

prolog:
---------------------------
reussit(X) :- serieux(X).
devoir(X) :- cons(X).
serieux(X) :- devoir(X).
cons(pascal).
cons(zoe).

2) Requête : reussit(X)
prolog nous renvoi les valeurs que peut prendre la variable X c'est à dire les étudiants qui réussissent.

3) Le resultat de la requête est : Pascal, Zoe

4)

===========================
EXERCICE 4
===========================

1) J'ai choisit les rougon macquart , on construit une base donnée de la forme :
pere(rougon, pierre).
mere(adelaide, pierre).

2) On définit parent de la manière suivante :
parent(X,Y) :- pere(X,Y).
parent(X,Y) :- mere(X,Y).
c'est à dire si c'est le père ou la mère, il s'agit du parent.

3)
---------------------------
| ?- parent(aristide, X).

X = maxime ? ;

X = clothilde ? ;

X = victor ? ;

La requete nous renvoie les enfants d'aristide(Saccard).
--------------------------
La requete parent(A,B) nous renvoie toutes les paires de (pere/mere, enfants).

6) On définit ancetre de manière recursive par :
----------------------------
ancetre(X,Y) :- parent(X,Y).
Pour le cas de base , si X est un parent de Y, alors il est son ancetre.

ancetre(X,Y) :- parent(Z, Y), ancetre(X, Z).
il s'agit de la recursion, si Z est un parent de Y alors X est un ancetre de Z.

Pour optenir les ancetres d'une personne on fait une requete de la forme :
--------------------
| ?- ancetre(X,maxime).

X = aristide ? ;

X = pierre ? ;

X = felicie ? ;

X = rougon ? ;

X = adelaide ? ;
--------------------




===========================
EXERCICE 5
===========================

1) On construit les prédicats de bases(et, ou, non) avec leur table de vérité par exemple :
non(0,1).
non(1,0).

2) requete : et(X,Y,1).
retourne les valeurs de X et Y qui rendent le AND vrai.

requete : et(0,0,R).
retourne le resultat de l'opération AND(0,0) c'est à dire 0.

requete : et(X,Y,R)
retournes toutes les combinaisons valide, c'est à dire la table de vérité du AND.

3) En prolog, les fonctions ne renvoient pas de résulats. Par consequent pour constuire le circuit, on dit que :
circuit(X,Y,1) :- et(X,Y,R0),non(R0,R1),  non(X, R2), xor(R1,R2,R3), non(R3,1).

4) La requete est circuit(X,Y,R) et retourne :
----------------------
R = 1
X = 1
Y = 1 ? ;

R = 1
X = 0
Y = 0 ? ;

R = 1
X = 0
Y = 1 ? ;

R = 0
X = 1
Y = 0 ? ;
----------------------
ce qui correspond bien à la table de vérité de l'implication.

5) requete : circuit(0,Y,R).
--------------------------
R = 1
Y = 0 ? ;

R = 1
Y = 1 ? ;
--------------------------
On veut savoir quels sont les choix possibles quand X est fixé à 0.
et on remarque bien que comme l'implication quand le premier terme est à 0, le résultat est toujours 1.

